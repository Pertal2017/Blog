---
title: 算法学习记录-2
author: Pertal
top: false
cover: false
toc: true
mathjax: true
tags:
  - - 数据结构与算法之美
  - - 极客时间
  - - 学习
categories:
  - 算法与数据结构
summary: '算法学习记录Day01,接着之前的时间复杂度问题'
abbrlink: 384faa82
date: 2020-07-12 17:37:11
password:
---

# 前言

昨天学习了主要是简单的概念学习与时间和空间复杂度分析的学习，今天学习的内容是时间与空间复杂度问题的第二部分，这部分主要是关于最好，最坏，平均，均摊时间复杂度相关的内容。

# 知识总结

## 最好、最坏、平均情况时间复杂度

### 最好、最坏情况时间复杂度

未优化的版本,不管找没找到都循环都会执行结束

```c
// n表示数组array的长度
//这段代码主要的功能是实现 
//查找一个数组里是否有和x相同的元素 
//如果相同返回下标 不相同那么-1 
int find(int[] array, int n, int x) {  
  //这里由上面可知道数组长度为n 空间复杂度为O(n)
  int i = 0;  //执行1次
  int pos = -1; //执行1次
  for (; i < n; ++i) { //执行n次
    if (array[i] == x)  //执行n次
        pos = i; //执行1次
  }
  //那么可以知道这个的时间复杂度为O(n)
  return pos;
}
```

优化后的版本，找到后就**跳出**，找不到那么执行整个循环，那么就有**多种**情况

```c
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

因为这个原因所以出现了**最好时间复杂度**和**最坏时间复杂度**以及**平均时间复杂度**。

**最好时间复杂度**就是能够**最快速**情况下找到**跳出**循环的情况，根据上面的例子我们可以知道**最好时间复杂度**就是在数组的**第一个元素**。

**最坏时间复杂度**说明了在**最不理想**的情况下**找出**元素，那么根据上面的例子我们可以推测知道**最坏时间复杂度**就是**没有**找到的情况，那么这时候可能要循环整整**n**次。

### 平均情况时间复杂度

这个需要单独拉出来讲，我们从上面知道**最好时间复杂度**为循环执行**一次**，**最坏时间复杂度**为没找到也就是说循环执行**n次**，那么这里总共的情况可能为**数组内$ [0,n-1] $**和**不在数组中**,那么这里总共的情况就是$$ n+1 $$次，那么这里我们把所有元素遍历的情况**累加**除以可能执行的次数，得到：
$$
\frac{1+2+3+\cdots+n+n}{n+1} = \frac{\frac{n(n+1)}{2}+n}{n+1}=\frac{\frac{n^2+n}{2}+\frac{2n}{2}}{n+1}=\frac{\frac{n^2+n+2n}{2}}{n+1}=\frac{n^2+3n}{2(n+1)}=\frac{n(n+3)}{2(n+1)}
$$
这里补充一下**等差数列**的求和公式为:
$$
S_n = \frac{n*(a_1+a_n)}{2}
$$
由上面的式子$ \frac{n(n+3)}{2(n+1)} $根据我们之前学习到的**大O表示法**中**<span style='color:red'>总复杂度</span>**等于**<span style='color:red'>量级最大</span>**的那段代码的复杂度可以得到下面这个式子:
$$
\frac{n(n+3)}{2(n+1)} = \frac{n^2+3n}{2n+2} = \frac{n^2}{2n}=\frac{n}{2}=n
$$
这里我们将**系数**，**低阶**，**常量**都省略后得到了**时间复杂度**为$ O(n) $，这个计算结论虽然正确但是没有考虑**概率**。

这里假设**数组中可能性**和**数组外可能性**都是$ \frac{1}{2} $,那么在数组中位置的**概率**为$ \frac{1}{n} $,也就是说明在数组中的各个位置的可能性为:
$$
\frac{1}{2} * \frac{1}{n} = \frac{1}{2n}
$$
那么这样我们就可以推出一个公式为：
$$
1 * \frac{1}{2n} + 2 * \frac{1}{2n} + 3 * \frac{1}{2n} + \cdots + n * \frac{1}{2n} + n * \frac{1}{2} = \frac{1+2+3+\cdots+n+n^2}{2n}=\frac{\frac{n(n+1)}{2}+n^2}{2n}
$$

$$
=\frac{\frac{n(n+1)}{2}+\frac{2n^2}{2}}{2n}=\frac{\frac{n^2+n+2n^2}{2}}{2n}=\frac{3n^2+n}{4n}=\frac{3n+1}{4}
$$

所以根据这个结果我们可以知道**真正**的值可能是$ \frac{3n+1}{4}  $,这个值在**概率论**中为**加权平均值**(**期望值**)，那么**平均时间复杂度**全称其实叫**加权平均时间复杂度**或者**期望时间复杂度**。

### 利用三种复杂度表示法的情况？

**一般情况**，不需要**考虑**三种情况，只有在**时间复杂度**有**量级差距**,才使用**最坏时间复杂度**，**最好时间复杂度**和**平均时间复杂度**的情况来区分问题。

## 均摊时间复杂度

### 均摊时间复杂度与平均复杂度的区分

**平均时间复杂度**只会在某些**特殊情况**使用，而**均摊时间复杂度**可能使用比**平均时间复杂度**更加**特殊**，更加**有限**。

```c
 // array表示一个长度为n的数组
 // 代码中的array.length就等于n
 int[] array = new int[n];
 int count = 0;
 
 void insert(int val) {
    if (count == array.length) {
       int sum = 0;
       for (int i = 0; i < array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }

    array[count] = val;
    ++count;
 }
```

**最坏时间复杂度**：插入时数组没有空位，那么这个时候代码最多执行n次，所以**时间复杂度**为$ O(n) $;

**最好时间复杂度**：插入时数组有空位，那么这个时候代码最多执行1次，所以**时间复杂度**为 $ O(1) $ ;

**平均时间复杂度**：分为**有空位**和**没有空位**两种情况，**有空位**总共有**n**种情况，**没有空位**发生总共有**1**种情况，那么总共会发生**n+1**种情况，每种情况的发生**概率**一致为$ \frac{1}{n+1} $，由此我们可以推算如下公式。
$$
1 * \frac{1}{n+1} + 1 * \frac{1}{n+1} + \cdots + 1 * \frac{1}{n+1} + n * \frac{1}{n+1} = \frac{n+n}{n+1} = \frac{2n}{n+1} = O(2) = O(1)
$$
**注**:这里**有空位**的**时间复杂度**都为$ O(1) $,因为执行 `array[count] = val;`

**没有空位**的**时间复杂度**为$ O(n) $,这里执行的是:

```C
if (count == array.length) { //执行1次
       int sum = 0; //执行1次
       for (int i = 0; i < array.length; ++i) { //这里数组假设的长度为n 那么这里执行n次
          sum = sum + array[i]; //循环块内 执行n次
       }
       array[0] = sum; //执行1次
       count = 1; //执行1次
    }
/*
从这里就可以知道根据之前学习的 三 大 原 则的第一条:
1. 只关注循环执行次数 最多 的代码
2. 加法法则: 总复杂度 等于 量级最大 的那段代码的复杂度
3. 乘法法则: 嵌套代码的复杂度 等于 嵌套 内外 代码复杂度的 乘积
我们可以知道这个情况的时间复杂度为O(n)
*/
```

### $ Insert() $代码块与$find()$代码块的对比

| $ Insert() $代码 | $ find() $代码 |
| ---------------- | -------------- |
| ``// array表示一个长度为n的数组``<br/> ``// 代码中的array.length就等于n``<br/> ``int[] array = new int[n];``<br/> ``int count = 0;``<br/> <br/> ``void insert(int val) {``<br/>    ``if (count == array.length) {``<br/>     ``  int sum = 0;``<br/>    ``   for (int i = 0; i < array.length; ++i) {``<br/>       ``   sum = sum + array[i];``<br/>    ``   }``<br/>    ``   array[0] = sum;``<br/>     ``  count = 1;``<br/>   `` }``<br/><br/>``    array[count] = val;``<br/>  ``  ++count;``<br/> ``}`` | ``// n表示数组array的长度``<br/>  ``int find(int[] array, int n, int x) {``<br/>  ``int i = 0;``<br/> `` int pos = -1;``<br/>  ``for (; i < n; ++i) {``<br/>   `` if (array[i] == x) {``<br/>    ``   pos = i;``<br/>  ``     break;``<br/>  ``  }``<br/>  ``}``<br/> `` return pos;``<br/>  ``}`` |

#### 1. 第一个区别

$ Insert() $中**大部分**复杂度为$ O(1) $,只有在**空间不够**时复杂度为$ O(n) $;$ find() $中**极端情况**复杂度为$ O(1) $。

#### 2. 第二个区别

$ Insert() $中$ O(1) $与$ O(n) $出现情况很**规律**，有**时序关系**，比如完成**一个**$O(n)$操作后面接着$ n - 1$个$O(1)$操作，如此循环。

### 总结

因此遇到这种代码我们不需要使用**平均时间复杂度**的分析步骤**找出概率**，**计算加权平均值**，而是使用一个新的方法**摊还分析法**，因此这种**时间复杂度**称为**均摊时间复杂度**，这里来说步骤就是**一次**复杂度**不同**的情况，后面跟着**一堆**复杂度**相同**的情况，并且**循环往复**；就比如上面的$ Insert() $函数为**一次**$ O(n) $操作，跟着$ n - 1$次的$ O(1) $操作，如此**循环往复**。

**总的来说**，**均摊时间复杂度**可以称为<span style='color:red;'>**特殊**</span>的**平均时间复杂度**。

# 课后思考题

```c

// 全局变量，大小为10的数组array，长度len，下标i。
int array[] = new int[10]; 
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i >= len) { // 数组空间不够了
     // 重新申请一个2倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来array数组中的数据依次copy到new_array
     for (int j = 0; j < len; ++j) {
       new_array[j] = array[j];
     }
     // new_array复制给array，array现在大小就是2倍len了
     array = new_array;
     len = 2 * len;
   }
   // 将element放到下标为i的位置，下标i加一
   array[i] = element;
   ++i;
}
```

**思路**

这里的$ add() $函数一共有两种情况**数组空间够**和**数组空间不够**两种情况：

首先我们分析**最好时间复杂度**，这个时候属于**数组空间够**的情况，那么这里只需要执行 `array[i] = element; //执行1次`以及 `++i; //执行一次`所以这种情况下**时间复杂度**为$ O(1) $；

其次分析**最坏时间复杂度**，这个时候属于**数据空间不够**的情况，那么这里下面需要执行的就是$ add() $函数的整个代码：

```c
void add(int element) {
   if (i >= len) { // 数组空间不够了 //执行1次
     // 重新申请一个2倍大小的数组空间
     int new_array[] = new int[len*2];  //执行1次
     // 把原来array数组中的数据依次copy到new_array
     for (int j = 0; j < len; ++j) { //执行10次 但是 由于不知道这里len可能的情况 所以 假设这里实际可以为n次
       new_array[j] = array[j]; //这个执行n次
     }
     // new_array复制给array，array现在大小就是2倍len了
     array = new_array; //执行1次
     len = 2 * len;  //执行1次
   }
   // 将element放到下标为i的位置，下标i加一
   array[i] = element; //执行1次
   ++i; //执行一次
}
```

那么这种情况下的**时间复杂度**其实为$O(n)$；

最后我们计算**平均复杂度**，我们可以从实际出发在**一次**时间复杂度为$ O(n) $的情况后，会出现 $ n - 1 $次时间复杂度为$ O(1) $的情况，因此这里其实需要计算的是**均摊时间复杂度**，这种情况下我们可以分析**数据空间够**有**n***种可能的情况，**数据空间不够**有**1**种情况，因此这里总共有**n+1**次情况，因此可以推出的公式为：
$$
1 * \frac{1}{n+1} + 1 * \frac{1}{n+1} + \cdots + 1 * \frac{1}{n+1} + n * \frac{1}{n+1} = \frac{n+n}{n+1} = \frac{2n}{n+1} = O(2) = O(1)
$$
其实这里可以发现和$ Insert() $函数的**均摊复杂度**是一致的，所以这一题其实就是举的一个**特定情况**的**平均时间复杂度**问题。