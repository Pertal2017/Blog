---
title: 算法学习记录-4
author: Pertal
top: false
cover: false
toc: true
mathjax: true
tags:
  - - 数据结构与算法之美
  - - 极客时间
  - - 学习
categories:
  - 算法与数据结构
summary: '算法相关的学习Day04,学习简单的链表'
abbrlink: d12c0fb7
date: 2020-07-22 15:34:43
password:
---

# 前言

了解数组的构成之后，紧接着今天学习的就是有关链表相关的内容，链表作为一个基础的数据结构，有着十分重要的使用场景，因此一般都是用来作为开头菜进行相关的内容学习。

# 知识总结

## 缓存

**定义**：缓存是一种提高**数据读取性能**的一种技术。

### 缓存的淘汰策略

1. 先进先出策略 FIFO(First In, First Out)：先进去的先出来
2. 最少使用策略 LFU(Least Frequently Used)：使用最少的淘汰
3. 最近最少使用策略 LRU(Least Recently Used)：最近使用最少的淘汰

## 数组与链表的比较

### 底层存储结构方面

**数组**需要**连续的内存空间**，**链表**通过**指针**将**零散的内存块**串起来使用。

<img src="https://s1.ax1x.com/2020/07/22/UHtTgJ.jpg" alt="UHtTgJ.jpg" style="zoom:50%;" />

### 查找、插入与删除

|      | 查找     | 插入     | 删除     | 内存     |
| ---- | -------- | -------- | -------- | -------- |
| 数组 | $ O(1) $ | $ O(n) $ | $ O(n) $ | 大小固定 |
| 链表 | $ O(n) $ | $ O(1) $ | $ O(1) $ | 动态扩容 |



## 链表的基本结构

### 单链表

每块零散的**内存块**称为**结点**，每个**结点**由**数据**和**后继指针**组成；**第一个**结点叫做**头结点**，**最后一个**结点叫做**尾结点**；**头结点**记录链表的**基地址**，**尾结点**的指针指向**空地址NULL**。

<img src="https://s1.ax1x.com/2020/07/22/UHtLHx.jpg" alt="UHtLHx.jpg" style="zoom:50%;" />

#### 链表的查找、插入与删除

**链表**的**随机访问**由于是**不连续空间**所以**时间复杂度**为$ O(n) $,**插入**与**删除**的**时间复杂度**都是$ O(1) $,因为只需要**修改**指针指向的**地址**即可。

### 循环链表

**循环链表**是一种**特殊**的**单链表**，区别在于**尾结点**，其**尾结点**指向**头结点**，**首尾**相连形成了**循环链表**。

<img src="https://s1.ax1x.com/2020/07/22/UHU8OA.jpg" alt="UHU8OA.jpg" style="zoom:50%;" />

### 双向链表

**单向链表**只有**一个**方向，**结点**只有一个**后继指针**指向后面的**结点**；**双向链表**支持**两个**方向，每个**结点**具有一个**后继指针**以及一个**前驱指针**。

<img src="https://s1.ax1x.com/2020/07/22/UHawAx.jpg" alt="UHawAx.jpg" style="zoom:50%;" />

### 单向链表与双向链表的比较

|          | 存储空间               | 删除结点中“值等于某个给定值”的结点 | 删除(插入)给定指针指向它的结点 | 有序链表        |
| -------- | ---------------------- | ---------------------------------- | ------------------------------ | --------------- |
| 单向链表 | 数据+后继指针          | 查找 $O(n)$   删除$O(1)$           | 查找$O(n)$  删除$ O(1) $       | 查找$ O(n) $    |
| 双向链表 | 数据+前驱指针+后继指针 | 查找 $O(n)$   删除$O(1)$           | 查找$ O(1) $ 删除$ O(1) $      | 查找$ O(logn) $ |

#### 空间换时间

内存空间**充足**，追求代码的**执行速度**，可以选择**空间复杂度**较**高**，**时间复杂度**较**低**的算法或者数据结构；反之，内存**紧缺**，选择**时间复杂度**较**高**，**空间复杂度**较**低**的算法或者数据结构。

对于**执行较慢**的程序，可以通过消耗**更多**的内存（空间换时间）来进行优化；而**消耗过多**内存的程序，可以通过消耗**更多**的时间（时间换空间）来降低内存的消耗。

#### 时间换空间，空间换时间的例子

以后补充

### 双向循环链表

**双向循环链表**指的是**首结点**的**前驱指针**指向**尾结点**的**数据**，**尾结点**的**后继指针**指向**首结点**的**数据**。

<img src="https://s1.ax1x.com/2020/07/22/UHBuxU.jpg" alt="UHBuxU.jpg" style="zoom:50%;" />

## LRU缓存淘汰算法的实现

我们维护一个**有序单链表**，越靠近链表**尾部**的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始**顺序遍历**链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从**原来**的位置**删除**，然后再**插入**到链表的**头部**。
2.  如果此数据没有在缓存链表中，又可以分为两种情况：
   1. 如果此时缓存**未满**，则将此结点**直接插入**到链表的**头部**；
   2. 如果此时缓存**已满**，则链表**尾结点删除**，将新的数据结点插入链表的**头部**。

### 如何通过数组实现LRU缓存淘汰策略

#### 参照链表方法

我们维护一个**有序的数组**，越靠近数组**尾部**的是越早之前访问的。当有一个新的数据被访问时，我们从数组头开始**遍历寻找**数组。

1. 如果此数据之前已经被缓存在数组中了，我们遍历得到这个数据对应的下标，将这个下标的数据临时存放一个变量中，并将从其下标位置之前的数据统统向后一位，然后将临时存放在变量中的数据写入头部。
2. 如果此数据没有在缓存数组中，分为两种情况：
   1. 如果此时数组未满，则将所有数据向后移动一位，将数据直接插入到头部
   2. 如果此时数组已满，则同样将所有数据向后移动一位，将数据插入到头部

#### 不参照链表

我们维护一个有序数组，越靠近数组头部的是越早之前访问的。当有一个新的数据被访问是，我们从数组头开始便利寻找数组。

1. 如果此数组之前已经被缓存在数组中了，我们遍历得到这个数据对应的下表，将这个下标的数据临时存放一个变量中，并将从其下标位置往后的数据统统向前一位，让后将临时存放在变量中的数据写入尾部
2. 如果此数据没有在缓存数组中，分为两种情况
   1. 如果此时数组未满，则将数据直接写入尾部
   2. 如果次数数组已满，贼将所有数据向前移动一位，将数据插入尾部

# 课后思考

如何判断一个字符串是否是回文字符串的问题，我想你应该听过，我们今天的题目就是基于这个问题的改造版本。如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？你有什么好的解决思路呢？相应的时间空间复杂度又是多少呢？

现有的解决思路：

1. 遍历一遍现有的链表，获得链表的数量，这里分为两种情况

   1. 单数的情况

      在此情况下记录中间结点，两两比对，由首结点和中间结点指向的结点开始进行比对即可，当首结点顺序指向到中间结点时比对结束

   2. 偶数的情况

      在此情况下取中间结点后一个结点，两两比对，由首结点和中间结点后一个结点指向的结点开始进行比对，当首结点顺序指向到中间结点时比对结束，此时将中间结点与中间结点的后一个结点再次比对即可。