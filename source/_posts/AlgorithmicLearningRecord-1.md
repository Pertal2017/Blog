---
title: 算法学习记录-1
author: Pertal
top: false
cover: false
toc: true
mathjax: true
tags:
  - - 数据结构与算法之美
  - - 极客时间
  - - 学习
categories:
  - 算法与数据结构
summary: '算法学习记录Day01,只是一些基本的介绍'
abbrlink: a146fb38
date: 2020-07-11 18:21:36
password:
---

# 前言

这个文章系列主要用来记录自己学习算法与数据结构的相关记录，期望自己可以每日都写，但是具体的话还是根据实际学习的情况来，主要是用来总结，也算是用来强迫鞭策自己进行知识内容的输出，毕竟学习这些内容是枯燥的，利用各种资源加上自己的总结来让自己更加了解这方面的知识对未来并没有什么坏处。

# 知识总结

## 算法与数据结构概念

1. **算法**表示操作数据的一组方法。
2. **数据结构**表示一组数据的存储结构。
3. **狭义上** 两者差不多主要是由前人总结下来的一些实际操作场景中的抽象方法，用来解决实际开发问题。
4. **两者关系**相辅相成，数据结构为算法**服务**，算法主要作用在特定的数据结构之上。

## 大O复杂度表示法

### 如何理解大O复杂度表示法

第一个简单代码分析

```c
 //这里假设的是每行执行时间为time
 int cal(int n) {
   int sum = 0;  // 这里为 1 * time
   int i = 1; // 这里为 2 * time 
   for (; i <= n; ++i) { // 这里分析主要执行的操作是++i操作 要执行n次 因为 i <= n
     //在这个里面的代码块执行是一个循环结构
     sum = sum + i; //这里执行的操作是n次
   }
   //循环结束之后 这里总共执行 2n * time次
   // 那么不算最后的输出 在这个内部函数逻辑里面它的总共执行次数为 (2n+2) * time
   return sum;
 }
```

这里对 `for(;i<=n;i++)` 的循环块代码利用另一种**循环结构**的分析

```c
while(true){
    //这里的if判断说明的是当i > n之后跳出这个循环
    if(i > n)	
        break;
    //这个操作其实是 i = i + 1; 那么通过上面的条件就知道这个要执行 n 次
    else 
        ++i;
    //这个操作是在循环块代码内部那么执行 n 次
    sum = sum + i;
}
// 因此最后这个循环体执行n + n 次的操作 也就是 2n
```

第二个部分的代码分析


```c
 //这里假设的是每行执行时间为time
 int cal(int n) {
   int sum = 0; //这里为 1 * time
   int i = 1; //这里为 2 * time
   int j = 1; //这里为 3 * time
   for (; i <= n; ++i) {  //这里分析主要执行的是++i操作 要执行n次 因为 i <= n
     // 这里是循环代码的内部操作
     j = 1; //这里执行的操作是n次
     for (; j <= n; ++j) { //这里分析主要执行的是++j操作 要执行n次 但是它在循环操作里面 所以就是 n*n次
       //这里是循环代码的内部操作
       sum = sum +  i * j; //这里执行的操作是n*n次
     }
     //跳出这个循环后这里总共执行n*n + n*n 也就是 2n^2
   }
    //跳出这个循环后 这里总共执行 2n + 2n^2
    //那么这个函数加在一起总共执行了 (2n^2 + 2n + 3) * time
 }
```

这里同样利用另一种**循环结构**进行分析

```c
while(true){
	if (i > n) //这里主要表示 i > n 的时候 跳出这个循环
		break;
	else
		++i; // 这里是说如果i <=n 那么执行 i = i + 1;的操作 那么这里总共执行 n 次
	j = 1; // 这里 在循环块内部 那么执行 n次
	while(true){
		if (j > n) // 这里主要表示 j > n 的时候跳出这个循环
			break;
		else
            // 这里是说如果 j <= n 的时候执行 j = j + 1的操作 那么在这个循环体内执行 n次 
            // 但是外面还有一个循环体  所以这里这个总共执行n * n次
			++j; 
        // 这说明 在循环体内执行n次 由于是循环体套循环体所以这里总共执行 n * n次
		sum = sum + i * j;
	}
}
// 因此最后这个循环体总共执行的操作是 2n^2 + 2n的操作
```

从这两个推导我们得到一个规律**所有代码的执行时间T(n)与每行代码的执行次数n成正比**,那么我们可以得到一个公式也就是
$$
T(n) = O(f(n))
$$
这里$ T(n) $表示的**代码总共执行时间**；$ n $ 表示的是**数据规模的大小**；$ f(n) $表示的是**每行代码执行的次数总和**；公式中的$ O $用来表示**代码执行时间**$ T(n) $与**执行次数**$ f(n) $表达式成正比。

**注意**：**大O**时间复杂度实际并不表示**具体**表示代码**真正**执行时间，而是表示**代码执行时间**随**数据规模**形成的一种**增长变化趋势**，也可以称为**渐进时间复杂度**，简称**时间复杂度**。

### 如何分析时间复杂度

#### 1. 只关注循环执行次数<span style='color:red'> 最多 </span>的代码

大O表示法表示的是**变化趋势**，因此**忽略**常量，低阶，系数，**只**记录**最大量级**；也就是说一段算法中，我们**关注**循环执行次数**最多**的一段即可。

```c

 int cal(int n) {
   int sum = 0; //执行一次
   int i = 1; //执行一次
   for (; i <= n; ++i) { //执行n次
     sum = sum + i; //执行n次
   }
   return sum;
 }
//那么这关注执行次数最多的代码 这里执行最多的是n次 也就表示为 O(n)
```



#### 2. 加法法则：<span style='color:red'>总复杂度</span>等于<span style='color:red'>量级最大</span>的那段代码的复杂度

```c

int cal(int n) {
   //这里是T1
   int sum_1 = 0;  // 执行1次
   int p = 1; // 执行1次
   for (; p <= 100; ++p) { //执行 100 次
     sum_1 = sum_1 + p;  //执行 100 次
   }
   //那么这一段执行最多的表示 100次 也就是常量 常量一般直接表示O(1)即可 

   //这里是T2
   int sum_2 = 0; // 执行 1 次
   int q = 1; // 执行 1 次
   for (; q <= n; ++q) { //执行 n 次
     sum_2 = sum_2 + q; //执行 n 次
   }
   //这里一段执行最多的表示 n 次 那么表示为 O(n)
  
   //这里是T3
   int sum_3 = 0; // 执行一次
   int i = 1; // 执行一次
   int j = 1; // 执行一次
   for (; i <= n; ++i) { //执行 n 次
     j = 1;  // 执行 n 次
     for (; j <= n; ++j) { // 执行 n * n 次
       sum_3 = sum_3 +  i * j; // 执行 n * n 次
     }
   }
  
   //这里一段执行最多的表示 n * n 次 那么表示O(n^2)
   return sum_1 + sum_2 + sum_3;
 }
```

上面这段代码我们分别假设为$ T1(n) $, $ T2(n) $,$ T3(n)$;那么$ T1(n) $的复杂度为$ O(1) $,$ T(2) $的复杂度为$ O(n) $,$ T(3) $的复杂度为$ O(n^2) $;由此我们可以知道$ T(n) = T1(n) + T2(n) + T3(n) $,那么最终的 $ T(n) = max(O(1),O(n),O(n^2))  $那么我们就可以知道这段代码的$ T(n) = O(n^2) $。

#### 3. 乘法法则：<span style='color:red'>嵌套代码的复杂度</span>等于嵌套<span style='color:red'>内外</span>代码复杂度的<span style='color:red'>乘积</span>

```c

int cal(int n) {
   int ret = 0;  //这里执行1次
   int i = 1; //这里执行 1 次
   for (; i < n; ++i) { //这里执行n次
     ret = ret + f(i); //这里执行n次
   } 
 } 
//这一段代码执行最多的表示 n 次 那么 表示 O(n)
 
 int f(int n) {
  int sum = 0; //这里执行1次
  int i = 1; // 这里执行1次
  for (; i < n; ++i) { //这里执行 n 次
    sum = sum + i; // 这里执行 n 次
  } 
  return sum; //这里执行1次
  //那么这一段代码中最多的执行为 n 次 那么 表示 O(n)
 }

/*
这里我们注意第6行这里其实嵌套了f(n)的表达式 那么 最终这段其实真正执行为 O(n) * O(n) 也就是 O(n^2)
*/
```

上面这段代码最有**争议**的地方就是**第6行**这里我们如果假设$ f(n) $只是普通操作那么执行次数为**n**次，但是这里**明显**知道利用的是下面的$ f(n) $函数因此，这里我们要**先**计算$ f(n) $的**时间复杂度**为$ O(n) $, 然后由于这个是**嵌套**在一个循环代码块中，所以最终就是:
$$
T(n) = O(n) * O(n) = O(n^2)
$$

## 常见的时间复杂度

![复杂度量级](https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg)

这里的复杂度可以分为**两类**一类是**多项式量级**，一类是**非多项式量级**；**非多项式量级**只有两个为$ O(2^n) $和$ O(n!) $,其余都是**多项式量级**。

**注**:**非多项式量级**的算法问题称为**NP(Non-Deterministic Polynomial,非确定多项式)**问题。

### 1. $ O(1) $

```c

 int i = 8; //执行一次
 int j = 6; // 执行一次
 int sum = i + j; // 执行一次
 
 for(int i = 0 ; i < 100 ; i++){ //执行100次
 	//
 }
```

$ O(1) $说明只要算法<span style='color:red'>不存在</span>**循环语句**，**递归语句**，那么即使有**成千上万**行代码，其**时间复杂度**表示为$  O(1)  $。

### 2. $ O(logn)、O(nlogn) $

```
 i=1; //执行一次
 while (i <= n)  { 
   i = i * 2; //执行2^n次
 }
```

这个比较难理解，看下图:

![指数增长](https://static001.geekbang.org/resource/image/9b/9a/9b1c88264e7a1a20b5954be9bc4bec9a.jpg)

由这个图我们可以得到$ n = 2 ^ x$那么我们解$ x $得到$ x = log_2n $,那么上面那段代码的**时间复杂度**就是$ O(log_2n) $。

```c
 i=1;
 while (i <= n)  {
   i = i * 3;
 }
```

由这个例子我们可以得到$ n = 3 ^ x $也就是解$ x $可以得到$ x = log_3n $，那么这段代码的**时间复杂度**就是$ O(log_3n) $；**但是**，由于**对数**可以相互转化所以这里都简写成$ O(logn) $了。

```
int cat(int n){
 int sum = 0;
 for(int i = 0 ; i < n ; i++){
 	sum = sum + f(i);
 }
}
int f(int n){
	int i = 1;
	while(i <= n){
		i = i * 2;
	}
}
```

上面我们知道**乘法法则**，那么$ O(nlogn) $就很好理解了，上面的代码**函数**$ f(n) $执行了$ O(logn) $,在**函数**$ cat(n) $中 `sum = sum + f(i)`这里就知道了


$$
O(n) = O_c(n) * O_f(n) = O(n) * O(logn) = O(nlogn)
$$



### 3. $ O(m+n)、O(m*n) $

```

int cal(int m, int n) {
  int sum_1 = 0; //这里执行1次
  int i = 1; //这里执行1次
  for (; i < m; ++i) { //这里执行m次
    sum_1 = sum_1 + i; //这里执行m次
  }

  int sum_2 = 0; //这里执行1次
  int j = 1; //这里执行1次
  for (; j < n; ++j) { //这里执行n次
    sum_2 = sum_2 + j; //这里执行n次
  }

  return sum_1 + sum_2;
}
```

上面的这段代码我们可以看到有**两个**循环结构他们循环的次数**各不相同**一个是**n**次还有一个是**m**次，因为无法**事先评估**m和n的次数，所以计算这种**时间复杂度**的时候，我们得出的结果为:
$$
O(N) = O(m) + O(n) = O(m+n)
$$
对于$ O(m * n) $其实就很容易了，可以参考下面的代码：

```c
int cal(int n) {
   int ret = 0;  //这里执行1次
   int i = 1; //这里执行 1 次
   for (; i < m; ++i) { //这里执行m次
     ret = ret + f(i); //这里执行m次
   } 
 } 
//这一段代码执行最多的表示 n 次 那么 表示 O(n)
 
 int f(int n) {
  int sum = 0; //这里执行1次
  int i = 1; // 这里执行1次
  for (; i < n; ++i) { //这里执行 n 次
    sum = sum + i; // 这里执行 n 次
  } 
  return sum; //这里执行1次
  //那么这一段代码中最多的执行为 n 次 那么 表示 O(n)
 }
```
这里我们可以计算得到：


$$
O(N) = O(m) * O(n) = O(m*n)
$$



## 空间复杂度

由于**空间复杂度**和**时间复杂度**基本上类似，所以这里给出一个定义**表示算法的存储空间与数据规模之间的增长关系**,全称**渐进空间复杂度**。

比如 `int [] a = new int[n]`那么这段就说明**空间复杂度**为$ O(n) $。

## 复杂度的比较图

![复杂度比较图](https://static001.geekbang.org/resource/image/49/04/497a3f120b7debee07dc0d03984faf04.jpg)

# 课后思考

## 你为什么要学习数据结构和算法呢？

作为一个学生党，对于数据结构和算法的了解仅仅只是在蓝桥杯比赛中实际运用过，但是听过很多前辈与学长的教诲都说明了其重要性，前段时间买了慕课网的一门课程，在学习时知道这些基础的知识对编程的原理掌握以及看懂开源框架十分的重要，因此要花费时间学习这些知识。

## 在过去的软件开发中，数据结构和算法在哪些地方帮到了你？

对于这个问题，作为一个学生其实这个对我的帮助并不多，因为我没参加过实际的项目开发，也不懂得实际的项目开发经验，现在唯一给我帮助的地方就只有当时参加**蓝桥杯**比赛，让我从比赛中获得了**省赛一等**的成绩，为后面申请**国家奖学金**给了一些帮助。

## 项目运行时会做性能测试，我们有必要进行时间与空间的复杂度分析呢？

虽然项目运行的时候会进行性能相关的测试，但是我们也有必要进行相关的时间与空间复杂度分析，我们可以对一些及其影响性能的功能代码进行分析，因为这些代码对性能要求极高，越节省对后面跑大规模的数据越有利。

## 对每段代码分析时间与空间复杂度，是否会浪费时间？

对每段代码的分析，可能浪费时间了，因为并不是每段代码都涉及到大量的操作，可能有些代码并不常执行，因此对一些重要的代码可以进行时间与空间的复杂度分析，毕竟有一个工种就叫算法工程师，虽然他们大部分可能涉及代码研究，但是对于一些代码的优化也是他们工种的工作内容之一。