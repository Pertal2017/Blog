---
title: 如何实现一个简单的单向链表
author: Pertal
top: false
cover: false
toc: true
mathjax: true
tags:
  - - 链表
categories:
  - 算法与数据结构
summary: 简单的单向链表的实现过程。
abbrlink: 135c306
date: 2020-07-23 14:33:17
password:
---

# 前期准备

这里主要是为了实现一个单向链表，那么首先我们得分析一个链表是如何形成的，以及其作用。

链表的形成可以比喻成当年的火烧赤壁当中曹操利用铁索链接船只，也可以类比现代航行的船队，从图片上我们可以明显观察到一个拖船后面跟着很多的货船，这里拖船就是**头节点**，而最后一个船呢就可以称为**尾结点**。

<img src="https://s1.ax1x.com/2020/07/23/ULwY5R.jpg" alt="ULwY5R.jpg" style="zoom:50%;" />

那么链表在计算机中的作用又是什么呢？

这里的了解我并不多，主要的作用肯定是更加方便的插入与删除相关的节点元素，让存储更加便利化，而应用场景可能需要后续补充了。

## 指针

指针的定义就不叙述了，这里需要使用指针的目的主要是链接下一个节点地址，指向当前节点的地址。

那么如何定义一个指针，以及指针该如何使用呢？

```c
#include <stdio.h>

int main(){
    //这种是定义一个整型变量
    int a = 10;
    //这种就是定义一个整型变量的指针
    int *p;
    //需要注意的是 指针指向的是一个地址，而不是值
    
    //在这里我们已经给a取了一个值10
   //那么怎样才能让指针取到这个值？
    p = &a;
    // &这个符号用来取得a这个变量的地址，然后将其存入p中，这时候的p就指向了a的地址
    
    //*的作用一共有三个分别是
    /*
    	1. 乘号  
    	2. 申明指针
    	3. 取得指针中的数据
    */
    //这里使用*号就是为了取得指针中指向地址的数据
    printf("%d", *p);
    
    
    return 0;
}
```



## 动态存储函数$ malloc() $

在**头文件**$ <stdlib.h> $中我们可以使用一个函数$ malloc() $，这个函数的主要作用是**分配字节**，有了这个函数，假使我们要分配一个整型数据的字节那么我们可以直接使用  `malloc(4)` 来分配字节，可能你会觉得这个并没啥用处，但是如果**你不知道某个类型的字节**，那么加上$ sizeof() $函数，你就可以轻松的为你的指针分配相对应的字节，这样的情况下你可以直接使用 `*`**间接运算符** 来直接进行赋值，这里简单举个例子。

```c
#include <stdio.h>
#include <stdlib.h>

int main(){
    //定义一个整型的p指针
	int *p;
    //为指针动态申请一个int类型的空间
    p = (int *)malloc(sizeof(int));
    //向指针中所指向的内存空间中存入10
    *p = 10;
    
    //输出指针p所指向的内存中的值
    printf("%d", *p);
	return 0;
}
```

$malloc()$的优势：

这里我并不能理解，可能不太明白，因此摘抄《啊哈！算法》中对于这个的解释：

为什么要用这么复杂的办法来存储数据呢？因为之前的方法，我们必须预先准确地知道所需变量的个数，也就是说我们必须定义出所有的变量。比如我们定义了100 个整型变量，那么程序就只能存储100 个整数，如果现在的实际情况是需要存储101个，那必须修改程序才可以。如果有一天你写的软件已经发布或者交付使用，却发现要存储1000 个数才行，那就不得不再次修改程序，重新编译程序，发布一个新版本来代替原来的。而有了$ malloc()$函数我们便可以在程序运行的过程中根据实际情况来申请空间。

**注**：$ malloc() $函数的返回值其实是 `void*`也就是说其可以强制转换成**任何类型**的指针，只要同指向的指针的**类型**对应即可。



## 链表节点的构造

链表节点主要有**两个**部分组成，其一是**数据**，其二是**后继指针**，当然这里我们只是考虑**单向链表**的情况，那么根据这两个要求我们实现的结构体如下:

```c
struct node{
	//用于存放整型数据
	int data;
	//后继指针用于指向与其相接的节点
	//节点的类型也是 struct node 那么指针就是struct node *
	struct node *next;
}
```



## 头结点与尾结点的处理

**头结点**由于其自身的原因，所以要单独先建立一个**头结点的指针**用于指向构建的节点；而**尾结点**的处理其实只需要其为NULL就可以了，因此通过这个逻辑我们可以构建好一个链表。

```c
//这里建立一个头结点的指针
struct node* head;
//起初并没有指向头结点的值
head = NULL;

//创建一个临时节点指针
struct node *p;
//动态申请一个空间，用来存放一个节点，并用临时指针指向这个空间
p = (struct node*)malloc(sizeof(struct node));
//创建一个当前节点指针
struct node *q;

//这里假设一个数据
int a = 10;

//-> 用于访问结构体内部成员 这里是将数据存储到节点的data域中
p->data = a;

//设置后继节点执行空，也就是当前节点的下一个节点为空
p->next = NULL;

//这里如果头结点是空那么头结点指向p，如果不是空那么当且节点的后继节点指向临时节点
if(head == NULL)
	head = p;
else
	q->next = p;
//当前的节点变成现在的临时节点
q=p;

```



# 实现一个完整的单向链表

通过上面的操作，我们就可以明白如何创建一个完整的单向链表，那么下面就是单向链表的完整代码

```c
#include <stdio.h>
#include <stdlib.h>

//创建节点的结构体
struct node {
    //数据域
    int data;
    //后继指针
    struct node *next;
}

int main(){
    
    //创建一个头节点
    struct node *head;
    //头结点先定义为NULL
    head = NULL;
    
    //创建一个临时节点指针
    struct node *p;
    
    //创建一个当前节点指针(这个指针赋值前是临时节点的前一个指针)
	struct node *q;
    
    //创建一个节点用来输出节点值
    struct node *t;
    
    //用来存放需要创建的节点个数
    int n;
    //用来临时存放数据域要储存的值
    int a;
    
    
    printf("请输入您需要创建的节点个数\n");
    scanf("%d", n);
    
    for(int i = 0 ; i < n ; i++){
		
        //给临时节点指针分配一个节点字节的空间
        p = (struct node*)malloc(struct node);
        //输入要存储的值
        scanf("%d", &a);
        //将值存入临时节点的数据域中
        p->data = a;
        //临时节点的后继指针指向空 这个主要是为了尾结点考虑
        p->next = NULL;
        
        //如果头结点是空那么临时节点指向头结点
        if(head == NULL)
            head = p;
       	//否则当前节点的后继指针指向临时节点
        else
            q->next = p;
        //当前节点更新为现在的临时节点
        q = p;
    }
    
    //t节点指向现在的头节点
    t = head;
    while(t != NULL){
        //输出当前的数据域中的值
        printf("%d", t->data);
        //将t重新指向当前节点的后继节点
      	t = t->next;
    }
    
    return 0;
}
```

